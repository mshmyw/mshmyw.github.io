---
title: "Brower Theory"
date: 2020-05-15T23:15:54+08:00
draft: false
categories: [""]
series: [""]
---

执行上下文

函数的执行上下文 和 全局的执行上下文

执行上下文中有变量环境和词法环境 

let const 的实现是对词法环境做了处理

词法环境也就是词法作用域

词法作用域是静态的

词法作用域的查找过程是：从当前查找 => 从外层环境查找 

这里的外层纯粹是代码的书写位置决定

假如它是动态的，那么应该是调用栈， 当前查找 => 栈的上一层

所以以下代码结果是1

```
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();
```



this 指向的缺陷

普通函数的调用 this 指向全局

某个对象的函数调用 则指向对象本身 类似主动调用了 call(xx)

内层嵌套的普通函数调用this指向全局 因它创建了自己的执行上下文



嵌套函数中的 this 不会从外层函数中继承

修正：

1 call 调用 改变this

2 将this 主动赋值 that = this

3 箭头函数 箭头函数不会创建自身的上下文环境，而是继承自外部函数



JS中栈和堆

栈的特性是后进先出，空间小，操作效率高，只需改变指针位置即可

堆的特点是空间大，但是分配释放效率低



栈是执行上下文中要用到的结构，维护执行上下文的状态

栈中存的是基本类型的值 对象类型的引用地址

栈中存的是对象类型的地址和值



微任务的微是什么意思呢？它只是说它必须优先执行，而不是说它是个小任务。

promise 是也是全部在主线程处理的吗？如果都是一个线程，那么怎么做到的异步呢？



**宏任务和微任务比喻： 你去银行排队 这个队列就是个宏任务 然后轮到你时**

**你要办卡 办完了说你还要理财 那么你要去重新排队吗？不是的 而是柜员接着处理你的理财 所以你的办卡跟理财就是你这个宏任务里的微任务队列**

为何要区分宏任务和微任务？

主要是为了任务优先级 紧急任务要先执行 这就是微任务

主线程（当前宏任务）主函数执行结束  => 微任务队列 => 当前宏任务执行结束 => 从消息队列取出下一个宏任务

## 0522

**浏览器原理** 

aysnc /await 的本质 是协程+promise

协程是比线程更细粒度，一个线程可有多个协程 同时只能运行一个协程

协程切换由用户控制



JS阻塞DOM构建 

HTML解析器以解析HTML文档流为主：

主要过程： html字节流 => token  dom节点 DOM树

在这中间 假如遇到了JS脚本 那么要暂停DOM构建或者解析 去执行JS脚本

因为脚本中有可能直接操作DOM 另外假如有JS需要下载 那么需要先下载JS

再执行JS 再进行DOM构建 而且假如有CSS文件 那么需要先构建CSSOM 然后才执行JS 因为JS中也有可能操作css 然后才回去继续执行DOM构建或者解析

所以优先级是： css文件加载 JS下载 JS执行 HTML解析 DOM构建 

生成DOM树的过程用到了**栈** 因为它要匹配一个tag的起始和终止。