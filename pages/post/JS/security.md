---
title: "Security"
date: 2019-11-19T21:45:50+08:00
draft: false
categories: ["security"]
series: ["security"]
---

## 跨域

### 什么是跨域

跨域是浏览器本身的限制，浏览器同源策略：协议、域名、端口有任何一个不同，都被当作是不同的域，也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求就会失败。

### [常见解决办法](https://juejin.im/post/5c6bca00f265da2dcf627aaa)

**JSONP**

JSONP 的原理很简单，就是利用 `` 标签没有跨域限制的漏洞。通过 `` 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。

JSONP 使用简单且兼容性不错，但是**只限于 `get` 请求。**

### CORS

CORS（Cross-Origin ResourceSharing）跨域资源共享，**定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。**

CORS背后的基本思想就是**使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。** 

**整个CORS通信过程，都是浏览器自动完成，不需要用户参与**。**对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。**

因此，实现CORS通信的关键是服务器。**只要服务器实现了CORS接口，就可以跨源通信。**

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

### postMessage

这是由H5提出来的的API。window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后,向目标窗口派发一个  MessageEvent 消息。

该MessageEvent消息有四个属性需要注意：

- message 属性表示该message 的类型；
- data 属性为 window.postMessage 的第一个参数；
- origin 属性表示调用window.postMessage() 方法时调用页面的当前状态；
- source 属性记录调用 window.postMessage() 方法的窗口信息。

### nginx代理跨域

**跨域原理：** 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

**实现思路：** 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

### WebSocket与NodeJs中间件跨域等其他方法

> 1 跨域 解决
> 2 call bind apply 区别
> 3 实现 jquery 元素选择器
> 4 元素提升
> 5 变量存储



## 变量提升

`ES5`中的`var` 和 `function `的申明都存在又变量提升，`ES6`中的 `let` 、 `const` 则不存在有变量提升。

**JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）**

> [JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明](https://www.runoob.com/js/js-hoisting.html)

以下两个实例将获得相同的结果：

实例1

```
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
```

实例2


```
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x
```

变量提升：函数声明和变量声明总是会被解释器悄悄地被"提升"到方法体的最顶部。

## JavaScript 初始化不会提升

JavaScript 只有声明的变量会提升，初始化的不会。

以下两个实例结果结果不相同：

### 实例 1

```
var x = 5; // 初始化 x
var y = 7; // 初始化 y

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x + " " + y;           // 显示 x 和 y
```

### 实例 2

```
var x = 5; // 初始化 x

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x + " " + y;      // 显示 x 和 y

var y = 7; // 初始化 y
```

## 在头部声明你的变量

对于大多数程序员来说并不知道 JavaScript 变量提升。

如果程序员不能很好的理解变量提升，他们写的程序就容易出现一些问题。

为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解。

其实主要理解 js 的解析机制就行。

遇到 script 标签的话 js 就进行预解析，将变量 var 和 function 声明提升，但不会执行 function，然后就进入上下文执行，上下文执行还是执行预解析同样操作，直到没有 var 和 function，就开始执行上下文。如:

JS执行过程：预解析（变量提升发生之地） 执行

### JS 变量存储方式

基本类型：基本类型有 Undefined，String，Number，Boolean，Null；按值访问，可以直接操作保存在变量的实际值。存储方式栈存储。

基本类型在复制值的时候，会在变量对象上创建一个新的值，然后把这个值复制到新变量分配的位置上面来
 引用类型：保存在内存中的对象，JS 不允许直接访问变量内存的位置，就是说不能直接操变量内存空间。存储方式是堆内存。引用类型可以添加属性和方法。

引用类型在复制值的时候，同样会将存储在变量对象中的值复制一份放到新变量的分配的空间上面，但是不同的是，这个值实际上就是一个副本指针，这个指针指向存储子堆中的一个对象，实际上是两个变量引用的是同一个对象，改变其中一个变量，也会影响另外的一个变量。

## 函数的参数传递是按照值访问的

**一、存储方式：**

（1）基本数据类型保存在栈内存；

（2）引用数据类型实际上是一个指针，这个指针也保存在栈中，但是这个指针指向的对象则保存在堆内存中。



**二、访问方式：**

（1）基本数据类型：按值访问，读写的是它们实际保存的值。

（2）引用数据类型：按引用访问，读写它们时需要先从栈中读取堆内存地址，然后找到保存在堆内存中的值。

**三、复制：**

（1）基本数据类型变量的复制：

从一个变量向另一个变量复制时，会在栈中创建一个新值，然后把值复制到为新变量分配的空间中。

（2）引用数据类型变量的复制：

复制的是存储在栈中的指针，将指针复制到栈中为新变量分配的空间中，而这个指针副本和原指针指向的是同一个堆内存中的对象；复制操作后两个变量实际上将引用同一个对象，因此改变其中一个将影响到另外一个。

**四、函数：**

JS中所有函数的参数都是按值传递。



[使用 javascript 替换 jQuery](https://segmentfault.com/a/1190000016568472)

